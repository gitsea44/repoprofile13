{'dependent': 'kerasrl', 'repo': '/wassname/rl-portfolio-management', 'language': 'Jupyter Notebook', 'description': 'Attempting to replicate "A Deep Reinforcement Learning Framework for the Financial Portfolio Management Problem" https://arxiv.org/abs/1706.10059 (and an openai gym environment)', 'readme': 'Attempting to replicate "A Deep Reinforcement Learning Framework for the Financial Portfolio Management Problem" by [Jiang et. al. 2017](https://arxiv.org/abs/1706.10059) [1].\n\n**Note2 (20190525):** vermouth1992 improved this environment during their final project, I reccomend you start with their [repo](https://github.com/vermouth1992/drl-portfolio-management). Also check out the [sagemaker tutorial](https://github.com/awslabs/amazon-sagemaker-examples/blob/master/reinforcement_learning/rl_portfolio_management_coach_customEnv/rl_portfolio_management_coach_customEnv.ipynb) which is based on vermouth1992\'s work.\n\n\nNote1 (2018): the paper\'s authors have put [the official code for the paper up and it works well](https://github.com/ZhengyaoJiang/PGPortfolio)\n\ntl;dr I managed to get 8% growth on training data, but it disapeared on test data. So I couldn\'t replicate it. However, RL papers can be very difficult to replicate due to bugs, framework differences, and hyperparameter sensistivity \n\n# About\n\nThis paper trains an agent to choose a good portfolio of cryptocurrencies. It\'s reported that it can give 4-fold returns in 50 days and the paper seems to do all the right things so I wanted to see if I could achieve the same results.\n\nThis repo includes an environment for portfolio management (with unit tests). Hopefully others will find this usefull as I am not aware of any other implementations (as of 2017-07-17).\n\nAuthor: wassname\n\nLicense: AGPLv3\n\n[[1](https://arxiv.org/abs/1706.10059)] Jiang, Zhengyao, Dixing Xu, and Jinjun Liang. "A Deep Reinforcement Learning Framework for the Financial Portfolio Management Problem." *arXiv preprint arXiv:1706.10059* (2017).\n\n# Results\n\nI have managed to overfit to the training data with no trading costs but it could not generalise to the test data. So far there have been poor results. I have not yet tried hyperparameter optimisation so it could be that parameter tweaking will allow the model to fit, or I may have subtle bugs.\n\n- VPG model,\n  - training: 190% portfolio growth in 50 days\n  - testing: 100% portfolio growth in 50 days\n\n![](https://raw.githubusercontent.com/wassname/rl-portfolio-management/8c74f136765f621eb45d484553b9f778e9243a84/docs/tensorforce-VPG-test.png)\n\nThis test period is directly after the training period and it looks like the usefullness of the models learned knowledge may decay as it moves away from its training interval.\n\nThere are other experiments stored as notebooks in past commits.\n\n# Installing\n\n- `git clone https://github.com/wassname/rl-portfolio-management.git`\n- `cd rl-portfolio-management`\n- `pip install -r requirements/requirements.txt`\n- `jupyter-notebook`\n    - Then open tensorforce-VPG.ipynb in jupyter\n    - Or try an alternative agent  with tensorforce-PPO.ipynb and train\n\n\n# Using the environment\n\nThese environments are dervied from the OpenAI environment class which you can learn about in their [documentation](https://gym.openai.com/docs/).\n\n\nThese environments come with 47k steps of training data and 8k test steps. Each step represents 30 minutes. Thanks to reddit user [ARRRBEEE](https://www.reddit.com/r/BitcoinMarkets/comments/694q0a/historical_pricing_data_for_poloniex_btceth_pairs) for sharing the data.\n\nThere are three output options which you can use as follows:\n\n```py\nimport gym\nimport rl_portfolio_management.environments  # this registers them\n\nenv = gym.envs.spec(\'CryptoPortfolioEIIE-v0\').make()\nprint("CryptoPortfolioEIIE has an history shape suitable for an EIIE model (see https://arxiv.org/abs/1706.10059)")\nobservation = env.reset()\nprint("shape =", observation["history"].shape)\n# shape = (5, 50, 3)\n\nenv = gym.envs.spec(\'CryptoPortfolioMLP-v0\').make()\nprint("CryptoPortfolioMLP history has an flat shape for a dense/multi-layer perceptron model")\nobservation = env.reset()\nprint("shape =", observation["history"].shape)\n# shape = (750,)\n\nenv = gym.envs.spec(\'CryptoPortfolioAtari-v0\').make()\nprint("CryptoPortfolioAtari history has been padded to represent an image so you can reuse models tuned on Atari games")\nobservation = env.reset()\nprint("shape =", observation["history"].shape)\n# shape = (50, 50, 3)\n```\n\nOr define your own:\n```py\nimport rl_portfolio_management.environments import PortfolioEnv\ndf_test = pd.read_hdf(\'./data/poloniex_30m.hf\', key=\'test\')\nenv_test = PortfolioEnv(\n  df=df_test,\n  steps=256,\n  scale=True,\n  augment=0.00,\n  trading_cost=0.0025,\n  time_cost=0.00,\n  window_length=50,\n  output_mode=\'mlp\'\n)\n```\n\nLets try it with a random agent and plot the results:\n\n\n```py\nimport numpy as np\nimport gym\nimport rl_portfolio_management.environments  # this registers them\n\nenv = gym.envs.spec(\'CryptoPortfolioMLP-v0\').make()\nsteps = 150\nstate = env.reset()\nfor _ in range(steps):\n    # The observation contains price history and portfolio weights\n    old_portfolio_weights = state["weights"]\n\n    # the action is an array with the new portfolio weights\n    # for out action, let\'s change the weights by around a 20th each step\n    action = old_portfolio_weights + np.random.normal(loc=0, scale=1/20., size=(4,))\n\n    # clip and normalize since the portfolio weights should sum to one\n    action = np.clip(action, 0, 1)\n    action /= action.sum()\n\n    observation, reward, done, info = env.step(action)\n\n    if done:\n        break\n\n# plot\nenv.render(\'notebook\')\n```\n\nUnsuprisingly, a random agent doesn\'t perform well in portfolio management. If it had chosen to bet on blue then black if could have outperformed any single asset, but hindsight is 20/20.\n\n![](docs/img/price_performance.png)\n![](docs/img/weights.png)\n\n# Plotting\n\nYou can run `env.render(\'notebook\')` or extract a pandas dataframe and plot how you like. To use pandas: `pd.DataFrame(gym.unwrapped.infos)`.\n\n\n# Tests\n\nWe have partial test coverage of the environment, just run:\n\n- `python -m pytest`\n\n\n# Files\n\n- enviroments/portfolio.py - contains an openai environment for porfolio trading\n- tensorforce-PPO-IEET.ipynb - notebook to try a policy gradient agent\n\n# Differences in implementation\n\nThe main differences from Jiang et. al. 2017 are:\n\n- The first step in a deep learning project should be to make sure the model can overfit, this provides a sanity check. So I am first trying to acheive good results with no trading costs.\n- I have not used portfolio vector memory. For ease of implementation I made the information available by using the last weights.\n- Instead of DPG ([deterministic policy gradient](http://jmlr.org/proceedings/papers/v32/silver14.pdf)) I tried and DDPG ([deep deterministic policy gradient]( http://arxiv.org/pdf/1509.02971v2.pdf)) and VPG (vanilla policy gradient) with generalized advantage estimation and PPO.\n- I tried to replicate the best performing CNN model from the paper and haven\'t attempted the LSTM or RNN models.\n- instead of selecting 12 assets for each window I chose 3 assets that have existed for the longest time\n- ~~My topology had an extra layer [see issue 3](https://github.com/wassname/rl-portfolio-management/issues/3)~~ fixed\n\n# TODO\n\nSee issue [#4](https://github.com/wassname/rl-portfolio-management/issues/4) and [#2](https://github.com/wassname/rl-portfolio-management/issues/2) for ideas on where to go from here\n', 'contents': "['.gitignore', 'data', 'docs', 'outputs', 'pytorch-deeprl-DDPG-EIIE.ipynb', 'readme.md', 'requirements', 'rl_portfolio_management', 'tensorforce-PPO-IEET.ipynb', 'test']", 'stars': 407, 'watchers': 407, 'forks': 146, 'deprepos': 'zero', 'deppacks': 'zero'}