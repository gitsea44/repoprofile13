{'dependent': 'kerasrl', 'repo': '/dickreuter/neuron_poker', 'language': 'Python', 'description': 'Texas holdem OpenAi gym poker environment, including virtual rendering and montecarlo for equity (python and c++ version)', 'readme': 'Neuron Poker: OpenAi gym environment for texas holdem poker\n===========================================================\n\nThis is an environment for training neural networks to play texas\nholdem. Please try to model your own players and create a pull request\nso we can collaborate and create the best possible player.\n\nUsage:\n------\n\nRun:\n\n- Install Anaconda, I would also recommend to install pycharm.\n- Create a virtual environment with ``conda create -n neuron_poker python=3.7``\n- Activate it with ``conda activate neuron_poker``, then install all required packages with ``pip install -r requirements.txt``\n- Run 6 random players playing against each other:\n  ``main.py random --render`` or\n- To manually control the players:``main.py keypress --render``\n- Example of genetic algorighm with self improvement: ``main.py equity_improvement --improvement_rounds=20 --episodes=10``\n- In order to use the c++ version of the equity calculator, you will also need to install visual studio 2019 (or gcc over cygwin may work as well). To use it, use the -c option when running main.py.\n- For more advanced users: ``main.py dqn_train -c`` will start training the deep Q agent with c++ montecarlo for faster calculation\n\n.. figure:: doc/table.png\n   :alt:\n\n\nAnalysis of the run\n~~~~~~~~~~~~~~~~~~~\n\nAt the end of an episode, the performance of the players can be observed via the summary plot.\n|image0|\n\nPackages and modules:\n~~~~~~~~~~~~~~~~~~~~~\n\nmain.py: entry point and command line interpreter. Runs agents with the gym. The docstring at the top of the file describes the command line options.\nThey are interpreted by docopt.\n\ngym\\_env\n~~~~~~~~\n\n-  ``env.py``: Texas Holdâ€™em unlimited openai gym environment &\n   ``rendering.py``: rendering graphics while playing\n\nagents\n~~~~~~\nPlease add your model based agents here.\n\n-  ``agent_random.py``: an agent making random decisions\n-  ``agent_keypress.py``: an agent taking decision via keypress\n-  ``agent_consider_equity.py``: an agent considering equity information\n-  ``agent_keras_rl_dqn.py``: Deep Q learning agent, using keras-rl for deep reinforcement learning\n-  ``agent_custom_q1.py``: Custom implementation of deep q learning\n\nNote that the observation property is a dictionary that contains all the information about the players and table that can be used to make a decision.\n\nCustom implementation of q learning\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nCustom impelemtation of reinforcement learning. This package is now in a separate repo:\nwww.github.com/dickreuter/tf_rl\n\n\ntools\n~~~~~\n\n-  ``hand_evaluator.py``: evaluate the best hand of multiple players\n-  ``helper.py``: helper functions\n-  ``montecarlo_numpy2.py``: fast numpy based montecarlo simulation to\n   calculate equity. Not yet working correctly. Some tests are failing. Feel free to fix them.\n-  ``montecarlo_python.py``: relatively slow python based montecarlo for equity calculation. Supports\n   preflight ranges for other players.\n-  ``montecarlo_cpp``: c++ implementation of equity calculator. Around 500x faster than python version\n\ntests\n^^^^^\n\n-  ``test_gym_env.py``: tests for the end.\n-  ``test_montecarlo.py``: tests for the hands evaluator and python\n   based equity calculator.\n-  ``test_montecarlo_numpy.py``: tests for the numpy montecarlo\n-  ``test_pylint.py``: pylint and pydoc tests to ensure pep8 standards and static code analysis\n\n\nRoadmap\n-------\n\nAgents\n~~~~~~\n\n- [x] Agent based on user interaction (keypress)\n- [x] Random agent\n- [x] Equity based strategy (i.e. call and bet above threshold)\n- [x] Equity based strategy with genetic algorithm, adjusting the treshold based on winning agent.\n- [x] C++ imlementation of equity calculator to significantly speed up runs\n- [x] Agent based on reinforcement learning with experience replay (Deep Q learning, based on keras-rl)\n- [/] Custom agents (see above section for more details)\n\nReinforcement learning: Deep Q agent\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n``neuron_poker.agents.agent_dqn`` implements a deep q agent with help of keras-rl.\nA number of parameters can be se:\n\n- nb_max_start_steps = 20  # maximum of random actions at the beginning\n- nb_steps_warmup = 75  # before training starts, should be higher than start steps\n- nb_steps = 10000  # total number of steps\n- memory_limit = int(nb_steps / 3)  # limiting the memory of experience replay\n- batch_size = 500  # number of items sampled from memory to train\n\nTraining can be observed via tensorboard (run ``tensorboard --logdir=./Graph`` from command line)\n|image2|\n\n\nHow to contribute\n-----------------\n\nLaunching from main.py\n~~~~~~~~~~~~~~~~~~~~~~\n\nIn ``main.py`` an agent is launched as follows (here adding 6 random\nagents to the table). To edit what is accepted to main.py via command\nline, simply add another line in the docstring at the top of main.py.\n\n.. code:: python\n\n    def random_action(render):\n        """Create an environment with 6 random players"""\n        env_name = \'neuron_poker-v0\'\n        stack = 500\n        self.env = gym.make(env_name, num_of_players=6, initial_stacks=stack)\n        for _ in range(num_of_plrs):\n            player = RandomPlayer(500)\n            self.env.add_player(player)\n\n        self.env.reset()\n\nAs you can see, as a first step, the environment needs to be created. As a second step, different agents need to be\nadded to the table. As a third step the game is kicked off with a reset. Agents with autoplay set to True will automatically\nplay, by having the action method called of their class. Alternatively you can use the PlayerShell class\nand the environment will require you call call the step function manually and loop over it. This may be helpful\nwhen using other packages which are designed to interface with the gym, such as keras-rl.\n\nAdding a new model / agent\n^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nAn example agent can be seen in random\\_agent.py\n\nTo build a new agent, an agent needs to be created, where the follwing\nfunction is modified. You will need to use the observation parameter,\nwhich contains the current state of the table, the players and and the\nagent itself, as a parameter to determine the best action.\n\n.. code:: python\n\n    def action(self, action_space, observation):  # pylint: disable=no-self-use\n        """Mandatory method that calculates the move based on the observation array and the action space."""\n        _ = observation  # not using the observation for random decision\n        this_player_action_space = {Action.FOLD, Action.CHECK, Action.CALL, Action.RAISE_POT, Action.RAISE_HAlF_POT}\n        possible_moves = this_player_action_space.intersection(set(action_space))\n        action = random.choice(list(possible_moves))\n        return action\n\nObserving the state\n~~~~~~~~~~~~~~~~~~~\n\nThe state is represented as a numpy array that contains the following\ninformation:\n\n.. code:: python\n\n    class CommunityData:\n        def __init__(self, num_players):\n            self.current_player_position = [False] * num_players  # ix[0] = dealer\n            self.stage = [False] * 4  # one hot: preflop, flop, turn, river\n            self.community_pot: float: the full pot of this hand\n            self.current_round_pot: float: the pot of funds added in this round\n            self.active_players = [False] * num_players  # one hot encoded, 0 = dealer\n            self.big_blind\n            self.small_blind\n\n\n    class StageData:  # as a list, 8 times:\n        """Preflop, flop, turn and river, 2 rounds each"""\n\n        def __init__(self, num_players):\n            self.calls = [False] * num_players  # ix[0] = dealer\n            self.raises = [False] * num_players  # ix[0] = dealer\n            self.min_call_at_action = [0] * num_players  # ix[0] = dealer\n            self.contribution = [0] * num_players  # ix[0] = dealer\n            self.stack_at_action = [0] * num_players  # ix[0] = dealer\n            self.community_pot_at_action = [0] * num_players  # ix[0] = dealer\n\n\n    class PlayerData:\n        "Player specific information"\n\n        def __init__(self):\n            self.position: one hot encoded, 0=dealer\n            self.equity_to_river: montecarlo\n            self.equity_to_river_2plr: montecarlo\n            self.equity_to_river_3plr: montecarlo\n            self.stack: current player stack\n\nHow to integrate your code on Github\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nIt will be hard for one person alone to beat the world at poker. That\'s\nwhy this repo aims to have a collaborative environment, where models can\nbe added and evaluated.\n\nTo contribute do the following:\n\n- Get Pycharm and build the virtual python environment. Use can do: ``pip install -r requirements.txt``\n- If you want to use the 500x faster c++ based equity calculator, also install visual studio, but this is not necessary\n- Clone your fork to your local machine. You can do this directly from pycharm: VCS --> check out from version control --> git\n- Add as remote the original repository where you created the fork from and call it upstream (the connection to your fork should be called origin). This can be done with vcs --> git --> remotes\n- Create a new branch: click on master at the bottom right, and then click on \'new branch\'\n- Make your edits.\n- Ensure all tests pass. Under file --> settings --> python integrated tools switch to pytest (see screenshot). |image1| You can then just right click on the tests folder and run all tests. All tests need to pass. Make sure to add your own tests by simply naming the funtion test\\_... \\\n- Make sure all the tests are passing. Best run pytest as described above (in pycharm just right click on the tests folder and run it). If a test fails, you can debug the test, by right clicking on it and put breakpoints, or even open a console at the breakpoint: https://stackoverflow.com/questions/19329601/interactive-shell-debugging-with-pycharm\n- Commit your changes (CTRL+K}\n- Push your changes to your origin (your fork) (CTRL+SHIFT+K)\n- To bring your branch up to date with upstream master, if it has moved on: rebase onto upstream master: click on your branch name at the bottom right of pycharm, then click on upstream/master, then rebase onto. You may need to resolve soe conflicts. Once this is done, make sure to always force-push (ctrl+shift+k), (not just push). This can be done by selecting the dropdown next to push and choose force-push (important: don\'t push and merge a rebased branch with your remote)\n- Create a pull request on your github.com to merge your branch with the upstream master.\n- When your pull request is approved, it will be merged into the upstream/master.\n\n.. |image0| image:: doc/pots.png\n.. |image1| image:: doc/pytest.png\n.. |image2| image:: doc/tensorboard-example.png', 'contents': "['.github', '.gitignore', '.pydocstyle', '.pylintrc', '.travis.yml', 'LICENSE', 'agents', 'doc', 'gym_env', 'log', 'main.py', 'pytest.ini', 'readme.rst', 'requirements.txt', 'setup.py', 'tests', 'tools']", 'stars': 133, 'watchers': 133, 'forks': 45, 'deprepos': 'zero', 'deppacks': 'zero'}